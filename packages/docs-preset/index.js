const fs = require("fs");
const path = require("path");
const toml = require("toml");

function resolveSidebarPath(siteDir, providedPath) {
    if (providedPath === false) {
        return undefined;
    }
    if (providedPath) {
        return providedPath;
    }

    const tsPath = path.resolve(siteDir, "sidebars.ts");
    if (fs.existsSync(tsPath)) {
        return tsPath;
    }

    const jsPath = path.resolve(siteDir, "sidebars.js");
    if (fs.existsSync(jsPath)) {
        return jsPath;
    }

    return undefined;
}

function normalizeLocales(locales) {
    if (!Array.isArray(locales)) {
        return null;
    }
    return Array.from(new Set(locales)).sort();
}

function arraysEqual(left, right) {
    if (!left || !right || left.length !== right.length) {
        return false;
    }
    for (let i = 0; i < left.length; i += 1) {
        if (left[i] !== right[i]) {
            return false;
        }
    }
    return true;
}

function getDefaultReferenceOptions(siteDir) {
    if (path.basename(siteDir) !== "website") {
        return {};
    }

    return {
        rootDir: "..",
        srcDir: "src",
    };
}

function resolveProjectRoot(siteDir) {
    if (path.basename(siteDir) === "website") {
        return path.resolve(siteDir, "..");
    }
    return siteDir;
}

function ensurePrismLua(themeConfig) {
    const options = { ...themeConfig };
    const prism = { ...(options.prism || {}) };
    const additional = Array.isArray(prism.additionalLanguages)
        ? prism.additionalLanguages.slice()
        : [];

    if (!additional.includes("lua")) {
        additional.push("lua");
    }

    prism.additionalLanguages = additional;
    options.prism = prism;
    return options;
}

function resolveStaticDirectories(existing, searchOptions) {
    const staticDirectories = Array.isArray(existing) && existing.length > 0
        ? existing.slice()
        : ["static"];

    const configuredOutDir = searchOptions && typeof searchOptions.outDir === "string"
        ? searchOptions.outDir.trim()
        : "";
    const searchOutDir = configuredOutDir || ".generated";

    if (!staticDirectories.includes(searchOutDir)) {
        staticDirectories.push(searchOutDir);
    }

    return staticDirectories;
}

function toSectionLabel(section) {
    if (!section || typeof section !== "string") {
        return "";
    }
    return section
        .split(/[-_]+/g)
        .filter(Boolean)
        .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
        .join(" ");
}

function listTopLevelDocsDirectories(docsDir) {
    if (!fs.existsSync(docsDir)) {
        return [];
    }
    const entries = fs.readdirSync(docsDir, { withFileTypes: true });
    return entries
        .filter((entry) => entry.isDirectory())
        .map((entry) => entry.name)
        .filter((name) => !name.startsWith(".") && !name.startsWith("_"))
        .sort((left, right) => left.localeCompare(right));
}

function writeGeneratedSidebarFile(siteDir, sidebars) {
    const generatedDir = path.join(siteDir, ".generated");
    const sidebarPath = path.join(generatedDir, "auto-sidebars.js");
    const content = `module.exports = ${JSON.stringify(sidebars, null, 2)};\n`;
    fs.mkdirSync(generatedDir, { recursive: true });
    fs.writeFileSync(sidebarPath, content, "utf8");
    return sidebarPath;
}

function buildAutoSidebarItems(sectionDirs) {
    const sidebars = {};
    for (const section of sectionDirs) {
        sidebars[section] = [{ type: "autogenerated", dirName: section }];
    }
    return sidebars;
}

function buildAutoNavbarItems(sectionDirs, sectionLabels) {
    return sectionDirs.map((section) => ({
        type: "docSidebar",
        sidebarId: section,
        label:
            (typeof sectionLabels[section] === "string" && sectionLabels[section].trim()) ||
            toSectionLabel(section),
    }));
}

function mergeNavbarItemsWithAuto(existingItems, autoItems) {
    const preserved = Array.isArray(existingItems)
        ? existingItems.filter((item) => item && item.type !== "docSidebar")
        : [];
    return [...autoItems, ...preserved];
}

function resolveAutoNavigationOptions(siteDir, docsOptions, siteConfig) {
    const navigationConfig =
        siteConfig && siteConfig.navigation && typeof siteConfig.navigation === "object"
            ? siteConfig.navigation
            : {};
    const navbarConfig =
        siteConfig && siteConfig.navbar && typeof siteConfig.navbar === "object"
            ? siteConfig.navbar
            : {};
    const useAutoNavigation =
        navigationConfig.autoNavigationFromDocsFolders === true ||
        navigationConfig.autoTabsFromDocsFolders === true ||
        navbarConfig.autoNavigationFromDocsFolders === true ||
        navbarConfig.autoTabsFromDocsFolders === true;
    if (!useAutoNavigation) {
        return null;
    }

    const docsDir = path.resolve(siteDir, docsOptions.path || "docs");
    const sectionDirs = listTopLevelDocsDirectories(docsDir);
    if (sectionDirs.length === 0) {
        return null;
    }

    const sectionLabels =
        navigationConfig.sectionLabels && typeof navigationConfig.sectionLabels === "object"
            ? navigationConfig.sectionLabels
            : navbarConfig.sectionLabels && typeof navbarConfig.sectionLabels === "object"
                ? navbarConfig.sectionLabels
                : {};
    const sidebars = buildAutoSidebarItems(sectionDirs);
    const sidebarPath = writeGeneratedSidebarFile(siteDir, sidebars);
    const navbarItems = buildAutoNavbarItems(sectionDirs, sectionLabels);
    return { sidebarPath, navbarItems };
}

function sanitizeRouteBasePath(value, lang) {
    const base = value || `reference/${lang}`;
    return base.replace(/^\/+|\/+$/g, "");
}

function buildRobloxLinkOptions(referenceOptions, overrides) {
    const options = overrides && typeof overrides === "object" ? { ...overrides } : {};
    const lang = (referenceOptions && referenceOptions.lang) || "luau";
    const routeBasePath = sanitizeRouteBasePath(
        referenceOptions && referenceOptions.routeBasePath,
        lang
    );
    const localBasePath = `/${routeBasePath}`;
    const localCategories = {
        Classes: { basePath: localBasePath },
        Docs: { basePath: localBasePath },
        ...(options.localCategories || {}),
    };
    return {
        robloxBaseUrl: options.robloxBaseUrl || "https://create.roblox.com/docs/reference/engine",
        localCategories,
        manifestPath: options.manifestPath || (referenceOptions && referenceOptions.manifestPath) || null,
        referenceLang: lang,
        routeBasePath,
    };
}


function findBakerywaveTomlPath(siteDir) {
    const projectRoot = resolveProjectRoot(siteDir);
    const candidates = [
        path.join(siteDir, "bakerywave.toml"),
        path.join(projectRoot, "bakerywave.toml"),
    ];

    for (const candidate of candidates) {
        if (fs.existsSync(candidate)) {
            return candidate;
        }
    }

    return null;
}

function resolveTomlPathOptions(tomlPath, options) {
    const resolved = { ...options };
    const baseDir = path.dirname(tomlPath);
    const pathKeys = ["rootDir", "input", "outDir", "manifestPath", "customDocConfig"];

    for (const key of pathKeys) {
        const value = resolved[key];
        if (!value || path.isAbsolute(value)) {
            continue;
        }
        resolved[key] = path.resolve(baseDir, value);
    }

    return resolved;
}

function loadBakerywaveReferenceOptions(siteDir) {
    const tomlPath = findBakerywaveTomlPath(siteDir);
    if (!tomlPath) {
        return {};
    }

    try {
        const raw = fs.readFileSync(tomlPath, "utf8");
        const parsed = toml.parse(raw);
        const reference = parsed.reference && typeof parsed.reference === "object" ? parsed.reference : {};
        return resolveTomlPathOptions(tomlPath, reference);
    } catch (error) {
        console.error(`[storybakery] bakerywave.toml 파싱 실패: ${tomlPath}`);
        console.error(error.message);
        return {};
    }
}

/**
 * bakerywave.toml에서 전체 설정을 로드합니다.
 */
function loadBakerywaveConfig(siteDir) {
    const tomlPath = findBakerywaveTomlPath(siteDir);
    if (!tomlPath) {
        return {};
    }

    try {
        const raw = fs.readFileSync(tomlPath, "utf8");
        return toml.parse(raw);
    } catch (error) {
        console.error(`[storybakery] bakerywave.toml 파싱 실패: ${tomlPath}`);
        console.error(error.message);
        return {};
    }
}

/**
 * bakerywave.toml에서 사이트 설정을 로드합니다.
 */
function loadBakerywaeSiteConfig(siteDir) {
    const config = loadBakerywaveConfig(siteDir);
    if (!config.site || typeof config.site !== "object") {
        return {};
    }
    return config.site;
}

function resolveSearchOptions(presetSearchOptions, siteConfigSearch) {
    if (presetSearchOptions === false) {
        return null;
    }

    if (presetSearchOptions && typeof presetSearchOptions === "object") {
        return { ...presetSearchOptions };
    }

    if (siteConfigSearch && typeof siteConfigSearch === "object" && siteConfigSearch.enabled === true) {
        return { ...siteConfigSearch };
    }

    return null;
}

function storybakeryI18nEnforcer(context, options) {
    const expected = (options && options.expected) || {};
    const expectedLocales = normalizeLocales(expected.locales);
    const expectedDefaultLocale = expected.defaultLocale;

    return {
        name: "storybakery-i18n-enforcer",
        loadContent() {
            const siteI18n = (context.siteConfig && context.siteConfig.i18n) || {};
            const errors = [];

            if (expectedLocales) {
                const actualLocales = normalizeLocales(siteI18n.locales);
                if (!actualLocales) {
                    errors.push("siteConfig.i18n.locales가 설정되어 있지 않습니다.");
                } else if (!arraysEqual(actualLocales, expectedLocales)) {
                    errors.push(
                        `siteConfig.i18n.locales가 정책과 다릅니다. expected=${expectedLocales.join(
                            ","
                        )} actual=${actualLocales.join(",")}`
                    );
                }
            }

            if (expectedDefaultLocale) {
                if (siteI18n.defaultLocale !== expectedDefaultLocale) {
                    errors.push(
                        `siteConfig.i18n.defaultLocale가 정책과 다릅니다. expected=${expectedDefaultLocale} actual=${siteI18n.defaultLocale || "undefined"
                        }`
                    );
                }
            }

            if (errors.length) {
                throw new Error(
                    `[storybakery] i18n 정책 위반:\n- ${errors.join("\n- ")}`
                );
            }
        },
    };
}

module.exports = function storybakeryDocsPreset(context, opts = {}) {
    const siteDir = context.siteDir;
    const robloxApiLinks = require("./remark/roblox-api-links");

    const docsOptions = {
        path: "docs",
        ...(opts.docs || {}),
    };

    const sidebarPath = resolveSidebarPath(siteDir, docsOptions.sidebarPath);
    if (sidebarPath) {
        docsOptions.sidebarPath = sidebarPath;
    }

    const themeOptions = opts.theme || {};
    const baseThemeConfig = (context.siteConfig && context.siteConfig.themeConfig) || {};

    // bakerywave.toml에서 사이트 설정 로드
    const bakerywaveSiteConfig = loadBakerywaeSiteConfig(siteDir);
    const siteSearchConfig =
        bakerywaveSiteConfig.search && typeof bakerywaveSiteConfig.search === "object"
            ? bakerywaveSiteConfig.search
            : null;
    const searchOptions = resolveSearchOptions(opts.search, siteSearchConfig);
    const autoNavigation = resolveAutoNavigationOptions(siteDir, docsOptions, bakerywaveSiteConfig);
    if (autoNavigation) {
        docsOptions.sidebarPath = autoNavigation.sidebarPath;
    }

    const themeConfigOverrides = {
        ...(opts.themeConfig || {}),
    };
    if (autoNavigation) {
        const baseNavbar =
            baseThemeConfig && baseThemeConfig.navbar && typeof baseThemeConfig.navbar === "object"
                ? baseThemeConfig.navbar
                : {};
        const overrideNavbar =
            themeConfigOverrides.navbar && typeof themeConfigOverrides.navbar === "object"
                ? themeConfigOverrides.navbar
                : {};
        const currentNavbarItems = Array.isArray(overrideNavbar.items)
            ? overrideNavbar.items
            : baseNavbar.items;
        themeConfigOverrides.navbar = {
            ...baseNavbar,
            ...overrideNavbar,
            items: mergeNavbarItemsWithAuto(currentNavbarItems, autoNavigation.navbarItems),
        };
    }

    const themeConfig = ensurePrismLua({
        ...baseThemeConfig,
        ...themeConfigOverrides,
        // bakerywave 사이트 설정을 themeConfig에 주입
        bakerywave: bakerywaveSiteConfig,
    });
    if (context.siteConfig) {
        context.siteConfig.themeConfig = themeConfig;
        if (searchOptions) {
            context.siteConfig.staticDirectories = resolveStaticDirectories(
                context.siteConfig.staticDirectories,
                searchOptions
            );
        }
    }
    const pagesOptions = {
        ...(opts.pages || {}),
    };

    const themes = [
        ["@docusaurus/theme-classic", themeOptions],
        ["@storybakery/docs-theme", opts.storyTheme || {}],
    ];

    const plugins = [];

    plugins.push(["@docusaurus/plugin-content-docs", docsOptions]);
    plugins.push(["@docusaurus/plugin-content-pages", pagesOptions]);

    // 검색 인덱스 플러그인
    if (searchOptions) {
        plugins.push(["@storybakery/docusaurus-plugin-search-index", searchOptions]);
    }

    const referenceDefaults = getDefaultReferenceOptions(siteDir);
    const referenceFromToml = loadBakerywaveReferenceOptions(siteDir);
    const referenceOptions =
        opts.reference === false
            ? null
            : { ...referenceDefaults, ...referenceFromToml, ...(opts.reference || {}) };
    if (referenceOptions) {
        plugins.push(["@storybakery/docusaurus-plugin-reference", referenceOptions]);
    }

    const robloxLinkOptions = buildRobloxLinkOptions(referenceOptions || {}, opts.robloxLinks);
    const docsRemarkPlugins = Array.isArray(docsOptions.remarkPlugins)
        ? docsOptions.remarkPlugins.slice()
        : [];
    docsRemarkPlugins.push([robloxApiLinks, robloxLinkOptions]);
    docsOptions.remarkPlugins = docsRemarkPlugins;

    const pagesRemarkPlugins = Array.isArray(pagesOptions.remarkPlugins)
        ? pagesOptions.remarkPlugins.slice()
        : [];
    pagesRemarkPlugins.push([robloxApiLinks, robloxLinkOptions]);
    pagesOptions.remarkPlugins = pagesRemarkPlugins;

    if (opts.i18n && (opts.i18n.locales || opts.i18n.defaultLocale)) {
        plugins.push([storybakeryI18nEnforcer, { expected: opts.i18n }]);
    }

    if (Array.isArray(opts.extraPlugins)) {
        plugins.push(...opts.extraPlugins);
    }

    if (Array.isArray(opts.extraThemes)) {
        themes.push(...opts.extraThemes);
    }

    return {
        themes,
        plugins,
    };
};
